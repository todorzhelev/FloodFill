<html> 
<head> 
<title>Path</title> 
<style> body { margin: 0; } canvas { width: 100%; height: 100% } </style> 
</head> 

<body> 

<script src="js/three.min.js"></script> 
<script src="js/TrackballControls.js"></script>
<script src="js/Detector.js"></script>
<script src="js/stats.min.js"></script>
<script src="fonts/helvetiker_bold.typeface.js"></script>
<script src="fonts/helvetiker_regular.typeface.js"></script>

<script>
     
    // --allow-file-access-from-files should be added when starting chrome
    // so local files can be loaded. This is because of security restrictions

    var renderer, camera, controls, scene, pointLight, stats;
    var mouseDown = false, mouseX = 0, mouseY = 0;
    var planes = [];
    var Cells = [];
    var IsTherePathToTarget;
    var floodFillTextMesh;
    var thereIsPathTextMesh;
    var thereIsNoPathTextMesh;

    var defaultSquareTexture = THREE.ImageUtils.loadTexture('textures/Square.jpg');
    var wallTexture = THREE.ImageUtils.loadTexture('textures/Square_visited_wall.jpg');
    var visitedTexture = THREE.ImageUtils.loadTexture('textures/Square_visited.jpg');
    var targetTexture = THREE.ImageUtils.loadTexture('textures/Square_target.jpg');
    var currentTexture = THREE.ImageUtils.loadTexture('textures/Square_current.jpg');
    var returningVisitedText = THREE.ImageUtils.loadTexture('textures/Square_returning1.jpg');

    var defaultSquareMaterial = new THREE.MeshPhongMaterial({ map: defaultSquareTexture });
    var wallMaterial = new THREE.MeshPhongMaterial({ map: wallTexture });
    var visitedMaterial = new THREE.MeshPhongMaterial({ map: visitedTexture });
    var targetMaterial = new THREE.MeshPhongMaterial({ map: targetTexture });
    var currentCellMaterial = new THREE.MeshPhongMaterial({ map: currentTexture });
    var returningFromRecursionMaterial = new THREE.MeshPhongMaterial({ map: returningVisitedText });
    var basicWhiteMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });

    var Setup3x3 =
    {
        mainTableSize: 3,
        fullTableSize: 5,
        // mat: [[0, 0, 0], [1, 1, 1], [1, 0, 0]],
        mat: [[0, 0, 0], [1, 1, 0], [1, 0, 0]],
        visited: [[0, 0, 0], [0, 0, 0], [0, 0, 0]],
        startX: 0,
        startY: 0,
        targetX: 2,
        targetY: 1
    }

    var Setup4x4 =
    {
        mainTableSize: 4,
        fullTableSize: 6,
        mat: [[0, 0, 0, 0], [0, 1, 0, 1], [0, 0, 1, 0], [0, 0, 0, 0]],
        visited: [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]],
        startX: 0,
        startY: 0,
        targetX: 3,
        targetY: 3
    }

    var Setup5x5 =
    {
        mainTableSize: 5,
        fullTableSize: 7,
        mat: [[0, 0, 0, 0, 0], [0, 1, 0, 1, 1], [0, 0, 1, 0, 0], [0, 0, 0, 1, 1], [1, 1, 0, 0, 0]],
        visited: [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]],
        startX: 0,
        startY: 0,
        targetX: 2,
        targetY: 3
    }

    var CustomSetup =
    {
        mainTableSize: 0,
        fullTableSize: 0,
        mat: [],
        visited: [],
        startX: 0,
        startY: 0,
        targetX: 0,
        targetY: 0
    }

    InitApp();

    var data = localStorage.getItem("setup");
    var setup;

    if (data == null) {
        setup = Setup5x5;
    }
    else if (data == "3x3") {
        setup = Setup3x3;
    }
    else if (data == "4x4") {
        setup = Setup4x4;
    }
    else if (data == "5x5") {
        setup = Setup5x5;
    }
    else if (data == "custom")
    {
        var matrix = localStorage.getItem("customSetupMatrix");
      
        var matrixRows = matrix.split('\n');
        var size = matrixRows.length;

        CustomSetup.mainTableSize = size;
        CustomSetup.fullTableSize = size + 2;

        CustomSetup.visited = new Array(size);
        for (var i = 0; i < size; i++)
        {
            CustomSetup.visited[i] = new Array(size);
        }

        for (var i = 0; i < size; i++)
        {
            for (var j = 0; j < size; j++)
            {
                CustomSetup.visited[i][j] = 0;
            }

        }

        CustomSetup.mat = new Array(size);
        for (var i = 0; i < size; i++)
        {
            CustomSetup.mat[i] = new Array(size);
        }

        for (var i = 0; i < size; i++)
        {
            var currentRowElements = matrixRows[i].split(' ');
            for (var j = 0; j < currentRowElements.length; j++)
            {
                CustomSetup.mat[i][j] = parseInt(currentRowElements[j]);
            }

        }

        var customStartX = localStorage.getItem("customSetupStartX");
        var customStartY = localStorage.getItem("customSetupStartY");
        var customTargetX = localStorage.getItem("customSetupTargetX");
        var customTargetY = localStorage.getItem("customSetupTargetY");

        CustomSetup.startX  = parseInt(customStartX);
        CustomSetup.startY  = parseInt(customStartY);
        CustomSetup.targetX = parseInt(customTargetX);
        CustomSetup.targetY = parseInt(customTargetY);

        setup = CustomSetup;
    }


    InitText(setup);
    InitAndRunSimulator(setup);

    MainLoop();

    function InitApp() {
        /////////////////////////////////////////////////////////////////////////////////////////////////////////

        //renderer
        renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        /////////////////////////////////////////////////////////////////////////////////////////////////////////

        //camera
        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000);
        camera.position.setZ(200);

        /////////////////////////////////////////////////////////////////////////////////////////////////////////

        //control over the mouse
        controls = new THREE.TrackballControls(camera);
        controls.addEventListener('change', Render);
        controls.minDistance = 17;
        controls.maxDistance = 250;
        controls.zoomSpeed = 0.7;
        controls.noRotate = true;

        /////////////////////////////////////////////////////////////////////////////////////////////////////////

        //scene
        scene = new THREE.Scene();

        /////////////////////////////////////////////////////////////////////////////////////////////////////////     

        // ambient light
        scene.add(new THREE.AmbientLight(0xffffff));

        var light = new THREE.DirectionalLight(0xffffff, 0.2);
        light.position.set(0, 50, 0);
        scene.add(light);

        /////////////////////////////////////////////////////////////////////////////////////////////////////////

        //listeners for mouse move mouse down and mouse up

        document.body.addEventListener('mousemove', function (e) { onMouseMove(e); }, false);
        document.body.addEventListener('mousedown', function (e) { onMouseDown(e); }, false);
        document.body.addEventListener('mouseup', function (e) { onMouseUp(e); }, false);


        /////////////////////////////////////////////////////////////////////////////////////////////////////////

        //statistics
        stats = new Stats();
        stats.setMode(0); // 0: fps, 1: ms

        // align down left
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.left = '0px';
        stats.domElement.style.bottom = '0px';

        document.body.appendChild(stats.domElement);

        /////////////////////////////////////////////////////////////////////////////////////////////////////////

        var backToMainMenu = document.createElement("BUTTON");
        var textBackToMM = document.createTextNode("Go back to main menu");
        backToMainMenu.appendChild(textBackToMM);
        backToMainMenu.style.position = 'absolute';
        backToMainMenu.style.top = '40px';
        backToMainMenu.style.right = '40px';
        backToMainMenu.onclick = GoBackToMainMenu;
        document.body.appendChild(backToMainMenu);
    }

    function GoBackToMainMenu() {
        window.document.location.href = 'index.html';
    }

    function InitText(setup) {
        var materialFront = new THREE.MeshBasicMaterial({ color: 0x000000 });
        var materialSide = new THREE.MeshBasicMaterial({ color: 0xffff00 });
        var materialArray = [materialFront, materialSide];

        // font: helvetiker, gentilis, droid sans, droid serif, optimer
        // weight: normal, bold

        var mainMessage = "Check if there is path from " + "(" + setup.startX + "," + setup.startY + ") to " + "(" + setup.targetX + "," + setup.targetY + ") by using flood fill";
        var textGeom = new THREE.TextGeometry(mainMessage,
        {
            size: 6, height: 0, curveSegments: 3,
            font: "helvetiker", weight: "normal", style: "normal",
            bevelThickness: 0, bevelSize: 0, bevelEnabled: false,
            material: 0, extrudeMaterial: 0
        });

        var textMaterial = new THREE.MeshFaceMaterial(materialArray);
        floodFillTextMesh = new THREE.Mesh(textGeom, textMaterial);

        floodFillTextMesh.position.set(-75, 20, 0);
        scene.add(floodFillTextMesh);


        var messagePath = "There is a path from " + "(" + setup.startX + "," + setup.startY + ") to " + "(" + setup.targetX + "," + setup.targetY + ")";
        var textGeomPath = new THREE.TextGeometry(messagePath,
        {
            size: 3, height: 0, curveSegments: 3,
            font: "helvetiker", weight: "normal", style: "normal",
            bevelThickness: 0, bevelSize: 0, bevelEnabled: false,
            material: 0, extrudeMaterial: 0
        });

        thereIsPathTextMesh = new THREE.Mesh(textGeomPath, textMaterial);
        thereIsPathTextMesh.visible = false;
        thereIsPathTextMesh.position.set(-75, 0, 0);
        scene.add(thereIsPathTextMesh);

        var messageNoPath = "There is no path from " + "(" + setup.startX + "," + setup.startY + ") to " + "(" + setup.targetX + "," + setup.targetY + ")";
        var textGeomNoPath = new THREE.TextGeometry(messageNoPath,
        {
            size: 3, height: 0, curveSegments: 10,
            font: "helvetiker", weight: "normal", style: "normal",
            bevelThickness: 0, bevelSize: 0, bevelEnabled: false,
            material: 0, extrudeMaterial: 0
        });

        thereIsNoPathTextMesh = new THREE.Mesh(textGeomNoPath, textMaterial);
        thereIsNoPathTextMesh.visible = false;
        thereIsNoPathTextMesh.position.set(-75, 0, 0);
        scene.add(thereIsNoPathTextMesh);
    }


    function InitAndRunSimulator(setup) {
        GenerateTable(setup);

        ClearOuterLayer(setup);

        InitSimulatorMainObjects(setup);

        IsTherePathToTarget = Simulate(setup.startX, setup.startY, setup);

        DrawSimulation();
    }

    //generates table consisting of mainTableSize+2 x mainTableSize+2 planes
    function GenerateTable(setup) {
        planes = new Array(setup.fullTableSize);

        for (var i = 0; i < setup.fullTableSize; i++) {
            planes[i] = new Array(setup.fullTableSize);
        }

        var width = 20;
        var height = 20;
        for (var i = 0; i < setup.fullTableSize; i++) {
            for (var j = 0; j < setup.fullTableSize; j++) {
                //plane with width 10 height 10 1 segment
                var geometry = new THREE.PlaneGeometry(width, height, 1, 1);

                var mesh = new THREE.Mesh(geometry, defaultSquareMaterial);

                mesh.translateX(width * j);

                //we want the next row to be below the current
                mesh.translateY(-height * i);

                //we store the planes in table, which we will use later
                planes[i][j] = mesh;
                scene.add(mesh);

                CreateCoordinatesText(i, j, mesh.position);
            }
        }
    }

    function CreateCoordinatesText(i, j, position) {
        var materialFront;

        var newX = i - 1;
        var newY = j - 1;

        //if (newX >= 0 && newY >= 0 && newX < mainTableSize && newY < mainTableSize && mat[newX][newY] != 1 && newX != startX && newY != startY &&
        //    newX != targetX && newY != targetY) {
        //    materialFront = new THREE.MeshBasicMaterial({ color: 0x000000 });
        //}
        //else
        {
            materialFront = new THREE.MeshBasicMaterial({ color: 0xffffff });
        }

        var materialSide = new THREE.MeshBasicMaterial({ color: 0xffff00 });
        var materialArray = [materialFront, materialSide];

        // font: helvetiker, gentilis, droid sans, droid serif, optimer
        // weight: normal, bold


        var message = "(" + newX + "," + newY + ")";
        var textGeom = new THREE.TextGeometry(message,
        {
            size: 3, height: 0, curveSegments: 3,
            font: "helvetiker", weight: "normal", style: "normal",
            bevelThickness: 0, bevelSize: 0, bevelEnabled: false,
            material: 0, extrudeMaterial: 0
        });

        var textMaterial = new THREE.MeshFaceMaterial(materialArray);
        coordinatesMesh = new THREE.Mesh(textGeom, textMaterial);
        textGeom.computeBoundingBox();
        var textWidth = textGeom.boundingBox.max.x - textGeom.boundingBox.min.x;
        var textHeight = textGeom.boundingBox.max.y - textGeom.boundingBox.min.y;

        coordinatesMesh.position.set(position.x - 0.5 * textWidth, position.y - 0.5 * textHeight, position.z);
        scene.add(coordinatesMesh);
    }

    //the outer layer of the table should not be visible
    //we want to show that at some point the recursion gets out of the borders
    //and of course this is not a valid cell, but still it is visited
    function ClearOuterLayer(setup) {
        for (var i = 0, j = 0; j < setup.fullTableSize; j++) {
            planes[i][j].material = basicWhiteMaterial;
        }

        for (var i = 1, j = setup.fullTableSize - 1; i < setup.fullTableSize; i++) {
            planes[i][j].material = basicWhiteMaterial;
        }

        for (var i = setup.fullTableSize - 1, j = setup.fullTableSize - 2; j >= 0; j--) {
            planes[i][j].material = basicWhiteMaterial;
        }

        for (var i = 0, j = 0; i < setup.fullTableSize; i++) {
            planes[i][j].material = basicWhiteMaterial;
        }
    }

    //changes the textures of the starting cell, walls and target cell
    function InitSimulatorMainObjects(setup) {
        planes[setup.startX + 1][setup.startY + 1].material = currentCellMaterial;
        planes[setup.targetX + 1][setup.targetY + 1].material = targetMaterial;

        for (var i = 0; i < setup.mainTableSize; i++) {
            for (var j = 0; j < setup.mainTableSize; j++) {
                if (setup.mat[i][j] == 1) {
                    planes[i + 1][j + 1].material = wallMaterial;
                }
            }
        }
    }

    function IsValidCell(cellX, cellY, setup)
    {
        if (cellX < 0 || cellX > setup.mainTableSize - 1 || cellY < 0 || cellY > setup.mainTableSize - 1) {
            return false;
        }

        if (setup.visited[cellX][cellY] == 1) {
            return false;
        }

        if (setup.mat[cellX][cellY] == 1) {
            return false;
        }

        return true;
    }

    //performs the simulation. 
    //visualization during the recursion turned out to be almost impossible
    function Simulate(currentX, currentY, setup) {
        console.log("(" + currentX + "," + currentY + ") \n");

        var cell = {
            x: currentX,
            y: currentY,
            isOutside: false,
            isWall: false,
            isReturingToThisCellFromRecursion: false
        }
        //we store the visited cells so we can visualize them later
        Cells.push(cell);

        setup.visited[currentX][currentY] = 1;

        if (currentX == setup.targetX && currentY == setup.targetY) {
            return true;
        }

        var right, down, left, top;

        if (IsValidCell(currentX, currentY + 1, setup)) {
            right = Simulate(currentX, currentY + 1, setup);
            var cellR = {
                x: currentX,
                y: currentY,
                isOutside: false,
                isWall: false,
                isReturingToThisCellFromRecursion: true
            }
            Cells.push(cellR);
        }
        else right = false;

        if (IsValidCell(currentX + 1, currentY, setup)) {
            down = Simulate(currentX + 1, currentY, setup);
            var cellD = {
                x: currentX,
                y: currentY,
                isOutside: false,
                isWall: false,
                isReturingToThisCellFromRecursion: true
            }
            Cells.push(cellD);
        }
        else down = false;

        if (IsValidCell(currentX, currentY - 1, setup)) {
            left = Simulate(currentX, currentY - 1, setup);
            var cellL = {
                x: currentX,
                y: currentY,
                isOutside: false,
                isWall: false,
                isReturingToThisCellFromRecursion: true
            }
            Cells.push(cellL);
        }
        else left = false;

        if (IsValidCell(currentX - 1, currentY, setup)) {
            top = Simulate(currentX - 1, currentY, setup);
            var cellT = {
                x: currentX,
                y: currentY,
                isOutside: false,
                isWall: false,
                isReturingToThisCellFromRecursion: true
            }
            Cells.push(cellT);
        }
        else top = false;

        return right || down || left || top;
    }

    //after we have stored the visited cells we can visualize them
    function DrawSimulation() {
        var delay = 1000;
        var interval = 0;
        var previousCell = null;
        for (var i = 0; i <= Cells.length; i++) {
            (
                function (i) {
                    setTimeout
                    (
                        function () {
                            if (previousCell != null)
                            {
                                    planes[previousCell.x + 1][previousCell.y + 1].material = visitedMaterial;
                            }

                            if (Cells[i].isReturingToThisCellFromRecursion) {
                                planes[Cells[i].x + 1][Cells[i].y + 1].material = returningFromRecursionMaterial;
                            }
                            else {
                                planes[Cells[i].x + 1][Cells[i].y + 1].material = currentCellMaterial;
                            }

                            previousCell = Cells[i];

                            if (i == Cells.length - 1) {
                                if (IsTherePathToTarget) {
                                    thereIsPathTextMesh.visible = true;
                                }
                                else {
                                    thereIsNoPathTextMesh.visible = true;
                                }
                            }
                        },
                        interval
                    )
                }
            )(i);


            interval += delay;
        }


    }

    function onMouseMove(event) {
        if (!mouseDown) {
            return;
        }

        var deltaX = event.clientX - mouseX;
        var deltaY = event.clientY - mouseY;
        mouseX = event.clientX;
        mouseY = event.clientY;

        rotatePlanet(deltaX, deltaY);
    }

    function onMouseDown(event) {
        mouseDown = true;
        mouseX = event.clientX;
        mouseY = event.clientY;
    }

    function onMouseUp(event) {
        mouseDown = false;
    }

    function rotatePlanet(deltaX, deltaY) {
        //planet.rotation.y += deltaX / 300;
        //planet.rotation.x += deltaY / 300;
    }


    function MainLoop() {
        requestAnimationFrame(MainLoop);
        stats.begin();

        Update();
        Render();

        stats.end();
    }

    function Update() {
        controls.update();
    }

    function Render() {
        renderer.setClearColor(0xffffff, 1);
        renderer.render(scene, camera);
    }
</script>

</body> 

</html>