<html> 
<head> 
<title>Path</title> 
<style> body { margin: 0; } canvas { width: 100%; height: 100% } </style> 
</head> 

<body> 

<script src="js/three.min.js"></script> 
<script src="js/TrackballControls.js"></script>
<script src="js/Detector.js"></script>
<script src="js/stats.min.js"></script>
<script src="fonts/helvetiker_bold.typeface.js"></script>
<script src="fonts/helvetiker_regular.typeface.js"></script>

<script>
     
    // --allow-file-access-from-files should be added when starting chrome
    // so local files can be loaded. This is because of security restrictions

    var renderer, camera, controls, scene, pointLight, stats;
    var mouseDown = false, mouseX = 0, mouseY = 0;
    var planes = [];
    var Cells = [];
    var IsTherePathToTarget;
    var floodFillTextMesh;
    var thereIsPathTextMesh;
    var thereIsNoPathTextMesh;

    var defaultSquareTexture = THREE.ImageUtils.loadTexture('textures/Square.jpg');
    var wallTexture          = THREE.ImageUtils.loadTexture('textures/Square_visited_wall.jpg');
    var visitedTexture       = THREE.ImageUtils.loadTexture('textures/Square_visited.jpg');
    var targetTexture        = THREE.ImageUtils.loadTexture('textures/Square_target.jpg');
    var currentTexture       = THREE.ImageUtils.loadTexture('textures/Square_current.jpg');

    var defaultSquareMaterial = new THREE.MeshPhongMaterial({ map: defaultSquareTexture });
    var wallMaterial          = new THREE.MeshPhongMaterial({ map: wallTexture });
    var visitedMaterial       = new THREE.MeshPhongMaterial({ map: visitedTexture });
    var targetMaterial        = new THREE.MeshPhongMaterial({ map: targetTexture });
    var currentCellMaterial   = new THREE.MeshPhongMaterial({ map: currentTexture });
    var basicWhiteMaterial    = new THREE.MeshBasicMaterial({ color: 0xffffff });

    var Setup3x3 =
    {
        mainTableSize: 3,
        fullTableSize: 5,
        mat: [[0, 0, 0], [1, 1, 1], [1, 0, 0]],
        visited: [[0, 0, 0], [0, 0, 0], [0, 0, 0]],
        startX: 0,
        startY: 0,
        targetX: 2,
        targetY: 1
    }

    var Setup4x4 =
    {
        mainTableSize: 4,
        fullTableSize: 6,
        mat: [[0, 0, 0, 0], [0, 1, 0, 1], [0, 0, 1, 0], [0, 0, 0, 0]],
        visited: [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]],
        startX: 0,
        startY: 0,
        targetX: 3,
        targetY: 3
    }

    var Setup5x5 =
    {
        mainTableSize: 5,
        fullTableSize: 7,
        mat: [[0, 0, 0, 0, 0], [0, 1, 0, 1, 1], [0, 0, 1, 0, 0], [0, 0, 0, 1, 1], [1, 1, 0, 0, 0]],
        visited: [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]],
        startX: 0,
        startY: 0,
        targetX: 2,
        targetY: 3
    }

    InitApp();

    var data = localStorage.getItem("setup");
    var setup;

    if (data == null)
    {
        setup = Setup5x5;
    }
    else if (data == "3x3") {
        setup = Setup3x3;
    }
    else if (data == "4x4") {
        setup = Setup4x4;
    }
    else if (data == "5x5") {
        setup = Setup5x5;
    }
    InitText(setup);
    InitAndRunSimulator(setup);

    MainLoop();

    function InitApp()
    { 
        /////////////////////////////////////////////////////////////////////////////////////////////////////////

        //renderer
        renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        /////////////////////////////////////////////////////////////////////////////////////////////////////////

        //camera
        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000);
        camera.position.setZ(150);

        /////////////////////////////////////////////////////////////////////////////////////////////////////////

        //control over the mouse
        controls = new THREE.TrackballControls(camera);
        controls.addEventListener('change', Render);
        controls.minDistance = 17;
        controls.maxDistance = 200;
        controls.zoomSpeed = 0.7;
        controls.noRotate = true;

        /////////////////////////////////////////////////////////////////////////////////////////////////////////

        //scene
        scene = new THREE.Scene();

        /////////////////////////////////////////////////////////////////////////////////////////////////////////     

        // ambient light
        scene.add(new THREE.AmbientLight(0xffffff));

        var light = new THREE.DirectionalLight(0xffffff, 0.2);
        light.position.set(0, 50, 0);
        scene.add(light);

        /////////////////////////////////////////////////////////////////////////////////////////////////////////

        //listeners for mouse move mouse down and mouse up

        document.body.addEventListener('mousemove', function (e){ onMouseMove(e);}, false);
        document.body.addEventListener('mousedown', function (e) {onMouseDown(e);}, false);
        document.body.addEventListener('mouseup', function (e) { onMouseUp(e); }, false);


        /////////////////////////////////////////////////////////////////////////////////////////////////////////

        //statistics
        stats = new Stats();
        stats.setMode(0); // 0: fps, 1: ms

        // align down left
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.left = '0px';
        stats.domElement.style.bottom = '0px';

        document.body.appendChild(stats.domElement);

        /////////////////////////////////////////////////////////////////////////////////////////////////////////

        var btn3x3 = document.createElement("BUTTON");     
        var text3x3 = document.createTextNode("Start 3x3 default simulation");       
        btn3x3.appendChild(text3x3);
        btn3x3.style.position = 'absolute';
        btn3x3.style.top = '0px';
        btn3x3.style.right = '0px';
        btn3x3.onclick = Start3x3Default;
        document.body.appendChild(btn3x3);

        /////////////////////////////////////////////////////////////////////////////////////////////////////////

        var btn4x4 = document.createElement("BUTTON");
        var text4x4 = document.createTextNode("Start 4x4 default simulation");
        btn4x4.appendChild(text4x4);
        btn4x4.style.position = 'absolute';
        btn4x4.style.top = '40px';
        btn4x4.style.right = '0px';
        btn4x4.onclick = Start4x4Default;
        document.body.appendChild(btn4x4);

        /////////////////////////////////////////////////////////////////////////////////////////////////////////

        var btn5x5 = document.createElement("BUTTON");
        var text5x5 = document.createTextNode("Start 5x5 default simulation");
        btn5x5.appendChild(text5x5);
        btn5x5.style.position = 'absolute';
        btn5x5.style.top = '80px';
        btn5x5.style.right = '0px';
        btn5x5.onclick = Start5x5Default;
        document.body.appendChild(btn5x5);

    }

    function Start3x3Default()
    {
        localStorage.setItem("setup", "3x3");
        location.reload();
    }

    function Start4x4Default()
    {
        localStorage.setItem("setup", "4x4");
        location.reload();
    }

    function Start5x5Default()
    {
        localStorage.setItem("setup", "5x5");
        location.reload();
    }

    function InitText(setup)
    {
        var materialFront = new THREE.MeshBasicMaterial({ color: 0x000000 });
        var materialSide = new THREE.MeshBasicMaterial({ color: 0xffff00 });
        var materialArray = [materialFront, materialSide];

        // font: helvetiker, gentilis, droid sans, droid serif, optimer
        // weight: normal, bold

        var mainMessage = "Check if there is path from " + "(" + setup.startX + "," + setup.startY + ") to " + "(" + setup.targetX + "," + setup.targetY + ") by using flood fill";
        var textGeom = new THREE.TextGeometry(mainMessage,
        {
            size: 6, height: 0, curveSegments: 3,
            font: "helvetiker", weight: "normal", style: "normal",
            bevelThickness: 0, bevelSize: 0, bevelEnabled: false,
            material: 0, extrudeMaterial: 0
        });

        var textMaterial = new THREE.MeshFaceMaterial(materialArray);
        floodFillTextMesh = new THREE.Mesh(textGeom, textMaterial);

        floodFillTextMesh.position.set(-75, 20, 0);
        scene.add(floodFillTextMesh);


        var messagePath = "There is a path from " + "(" + setup.startX + "," + setup.startY + ") to " + "(" + setup.targetX + "," + setup.targetY + ")";
        var textGeomPath = new THREE.TextGeometry(messagePath,
        {
            size: 3, height: 0, curveSegments: 3,
            font: "helvetiker", weight: "normal", style: "normal",
            bevelThickness: 0, bevelSize: 0, bevelEnabled: false,
            material: 0, extrudeMaterial: 0
        });

        thereIsPathTextMesh = new THREE.Mesh(textGeomPath, textMaterial);
        thereIsPathTextMesh.visible = false;
        thereIsPathTextMesh.position.set(-75, 0, 0);
        scene.add(thereIsPathTextMesh);

        var messageNoPath = "There is no path from " + "(" + setup.startX + "," + setup.startY + ") to " + "(" + setup.targetX + "," + setup.targetY + ")";
        var textGeomNoPath = new THREE.TextGeometry(messageNoPath,
        {
            size: 3, height: 0, curveSegments: 10,
            font: "helvetiker", weight: "normal", style: "normal",
            bevelThickness: 0, bevelSize: 0, bevelEnabled: false,
            material: 0, extrudeMaterial: 0
        });

        thereIsNoPathTextMesh = new THREE.Mesh(textGeomNoPath, textMaterial);
        thereIsNoPathTextMesh.visible = false;
        thereIsNoPathTextMesh.position.set(-75, 0, 0);
        scene.add(thereIsNoPathTextMesh);
    }


    function InitAndRunSimulator(setup)
    {
        GenerateTable(setup);

        ClearOuterLayer(setup);

        InitSimulatorMainObjects(setup);

        IsTherePathToTarget = Simulate(setup.startX, setup.startY, setup);

        DrawSimulation();
    }

    //generates table consisting of mainTableSize+2 x mainTableSize+2 planes
    function GenerateTable(setup)
    {
        planes = new Array(setup.fullTableSize);

        for (var i = 0; i < setup.fullTableSize; i++) {
            planes[i] = new Array(setup.fullTableSize);
        }

        var width  = 20;
        var height = 20;
        for (var i = 0; i < setup.fullTableSize; i++)
        {
            for (var j = 0; j < setup.fullTableSize; j++)
            {
                //plane with width 10 height 10 1 segment
                var geometry = new THREE.PlaneGeometry(width, height, 1, 1);

                var mesh = new THREE.Mesh(geometry, defaultSquareMaterial);

                mesh.translateX(width * j);

                //we want the next row to be below the current
                mesh.translateY(-height * i);

                //we store the planes in table, which we will use later
                planes[i][j] = mesh;
                scene.add(mesh);

                CreateCoordinatesText(i, j,mesh.position);
            }
        }
    }

    function CreateCoordinatesText(i, j,position)
    {
        var materialFront;

        var newX = i - 1;
        var newY = j - 1;

        //if (newX >= 0 && newY >= 0 && newX < mainTableSize && newY < mainTableSize && mat[newX][newY] != 1 && newX != startX && newY != startY &&
        //    newX != targetX && newY != targetY) {
        //    materialFront = new THREE.MeshBasicMaterial({ color: 0x000000 });
        //}
        //else
        {
            materialFront = new THREE.MeshBasicMaterial({ color: 0xffffff });
        }

        var materialSide = new THREE.MeshBasicMaterial({ color: 0xffff00 });
        var materialArray = [materialFront, materialSide];

        // font: helvetiker, gentilis, droid sans, droid serif, optimer
        // weight: normal, bold

       
        var message = "(" + newX + "," + newY + ")";
        var textGeom = new THREE.TextGeometry(message,
        {
            size: 3, height: 0, curveSegments: 3,
            font: "helvetiker", weight: "normal", style: "normal",
            bevelThickness: 0, bevelSize: 0, bevelEnabled: false,
            material: 0, extrudeMaterial: 0
        });

        var textMaterial = new THREE.MeshFaceMaterial(materialArray);
        coordinatesMesh = new THREE.Mesh(textGeom, textMaterial);
        textGeom.computeBoundingBox();
        var textWidth  = textGeom.boundingBox.max.x - textGeom.boundingBox.min.x;
        var textHeight = textGeom.boundingBox.max.y - textGeom.boundingBox.min.y;

        coordinatesMesh.position.set(position.x - 0.5 * textWidth, position.y - 0.5 * textHeight, position.z);
        scene.add(coordinatesMesh);
    }

    //the outer layer of the table should not be visible
    //we want to show that at some point the recursion gets out of the borders
    //and of course this is not a valid cell, but still it is visited
    function ClearOuterLayer(setup)
    {
        for (var i = 0, j = 0; j < setup.fullTableSize; j++) {
            planes[i][j].material = basicWhiteMaterial;
        }

        for (var i = 1, j = setup.fullTableSize - 1; i < setup.fullTableSize; i++) {
            planes[i][j].material = basicWhiteMaterial;
        }

        for (var i = setup.fullTableSize - 1, j = setup.fullTableSize - 2; j >= 0; j--) {
            planes[i][j].material = basicWhiteMaterial;
        }

        for (var i = 0, j = 0; i < setup.fullTableSize; i++) {
            planes[i][j].material = basicWhiteMaterial;
        }
    }

    //changes the textures of the starting cell, walls and target cell
    function InitSimulatorMainObjects(setup)
    {
        planes[setup.startX + 1][setup.startY + 1].material = currentCellMaterial;
        planes[setup.targetX + 1][setup.targetY + 1].material = targetMaterial;

        for (var i = 0; i < setup.mainTableSize; i++)
        {
            for (var j = 0; j < setup.mainTableSize; j++)
            {
                if (setup.mat[i][j] == 1)
                {
                    planes[i + 1][j + 1].material = wallMaterial;
                }
            }
        }
    }

    //performs the simulation. 
    //visualization during the recursion turned out to be almost impossible
    function Simulate(currentX, currentY,setup)
    {
        console.log("(" + currentX + "," + currentY + ") \n");

        var cell = {
            x: currentX,
            y: currentY,
            isOutside: false,
            isWall: false
        }
        //we store the visited cells so we can visualize them later
        Cells.push(cell);

        if (currentX < 0 || currentX > setup.mainTableSize - 1 || currentY < 0 || currentY > setup.mainTableSize - 1)
        {
            cell.isOutside = true;
            return false;
        }

        if (setup.visited[currentX][currentY] == 1)
        {
            return false;
        }

        if (setup.mat[currentX][currentY] == 1)
        {
            cell.isWall = true;
            return false;
        }

        setup.visited[currentX][currentY] = 1;

        if (currentX == setup.targetX && currentY == setup.targetY)
        {
            return true;
        }

        var right = Simulate(currentX, currentY + 1,setup);
        var down  = Simulate(currentX + 1, currentY,setup);
        var left  = Simulate(currentX, currentY - 1,setup);
        var top   = Simulate(currentX - 1, currentY,setup);

        return right || down || left || top;
    }

    //after we have stored the visited cells we can visualize them
    function DrawSimulation()
    {
        var delay = 1000;
        var interval = 0;
        var previousCell = null;
        for (var i = 0; i <= Cells.length; i++)
        {
            (
                function (i)
                {
                    setTimeout
                    (
                        function ()
                        {
                            if (previousCell != null)
                            {
                                if (previousCell.isOutside)
                                {
                                    planes[previousCell.x + 1][previousCell.y + 1].material = new THREE.MeshBasicMaterial({ color: 0xffffff });
                                    //i want to clear the last visited cell which is outside the table
                                    //thats why i iterate to Cells.lengths + 1
                                    if (i == Cells.length)
                                    {
                                        return;
                                    }
                                }
                                else if (previousCell.isWall)
                                {
                                    planes[previousCell.x + 1][previousCell.y + 1].material = wallMaterial;
                                }
                                else
                                {
                                    planes[previousCell.x + 1][previousCell.y + 1].material = visitedMaterial;
                                }
                            }

                            planes[Cells[i].x + 1][Cells[i].y + 1].material = currentCellMaterial;

                            previousCell = Cells[i];

                            if (i == Cells.length - 1)
                            {
                                if (IsTherePathToTarget)
                                {
                                    thereIsPathTextMesh.visible = true;
                                }
                                else
                                {
                                    thereIsNoPathTextMesh.visible = true;
                                }
                            }
                        },
                        interval
                    )
                }
            )(i);

            
            interval += delay;
        }

       
    }

    function onMouseMove(event)
    {
        if (!mouseDown)
        {
            return;
        }

        var deltaX = event.clientX - mouseX;
        var deltaY = event.clientY - mouseY;
        mouseX = event.clientX;
        mouseY = event.clientY;

        rotatePlanet(deltaX, deltaY);
    }

    function onMouseDown(event)
    {
        mouseDown = true;
        mouseX = event.clientX;
        mouseY = event.clientY;
    }

    function onMouseUp(event)
    {
        mouseDown = false;
    }

    function rotatePlanet(deltaX, deltaY)
    {
        //planet.rotation.y += deltaX / 300;
        //planet.rotation.x += deltaY / 300;
    }


    function MainLoop()
    {
        requestAnimationFrame(MainLoop);
        stats.begin();

            Update();
            Render();

        stats.end();
    }

    function Update()
    {
        controls.update();
    }

    function Render()
    {
        renderer.setClearColor(0xffffff, 1);
        renderer.render(scene, camera);
    }
</script>

</body> 

</html>